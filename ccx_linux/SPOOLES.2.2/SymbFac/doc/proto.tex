\par
\section{Prototypes and descriptions of {\tt SymbFac} methods}
\label{subsection:SymbFac:proto}
\par
This section contains brief descriptions including prototypes
of all methods that belong to the {\tt SymbFac} object.
\par
\subsection{Symbolic factorization methods}
\label{subsection:SymbFac:proto:symbfac}
\par
\begin{enumerate}
%-----------------------------------------------------------------------
\item
\begin{verbatim}
IVL * SymbFac_initFromGraph ( ETree *etree, Graph *graph ) ;
\end{verbatim}
\index{SymbFac_initFromGraph@{\tt SymbFac\_initFromGraph()}}
This symbolic factorization method takes a {\tt Graph} object
as input.
This method constructs an {\tt IVL} object that contains one list
per front. 
List {\tt ilist} contains the internal and external vertices
for front {\tt ilist}.
If the input {\tt graph} is a compressed graph, then the lists of
compressed vertices make little sense; they must be converted to
original vertices.
To do this, see the {\tt IVL\_expand()} method.
The {\tt nodwghtsIV} and {\tt bndwghtsIV} objects for the {\tt
ETree} object are updated using information from the symbolic
factorization.
\par \noindent {\it Error checking:}
If {\tt etree} or {\tt graph} is {\tt NULL},
or if ${\tt nfront} < 1$,
or if ${\tt nvtx} < 1$,
or if $\mbox{\tt graph->nvtx} \ne {\tt nvtx}$,
an error message is printed and the program exits.
%-----------------------------------------------------------------------
\item
\begin{verbatim}
IVL * SymbFac_initFromInpMtx ( ETree *etree, InpMtx *inpmtx ) ;
\end{verbatim}
\index{SymbFac_initFromInpMtx@{\tt SymbFac\_initFromInpMtx()}}
This symbolic factorization method takes a {\tt InpMtx} object
as input.
This method constructs an {\tt IVL} object that contains one list
per front. 
List {\tt ilist} contains the internal and external vertices
for front {\tt ilist}.
We assume that both the {\tt ETree} and {\tt InpMtx} objects have
had been permuted into their final ordering.
The {\tt nodwghtsIV} and {\tt bndwghtsIV} objects for the {\tt
ETree} object are updated using information from the symbolic
factorization.
\par \noindent {\it Error checking:}
If {\tt etree} or {\tt inpmtx} is {\tt NULL},
or if the coordinate type of {\tt inpmtx} is not {\tt
INPMTX\_BY\_CHEVRONS},
or if the storage mode of {\tt inpmtx} is not {\tt
INPMTX\_BY\_VECTORS},
or if ${\tt nfront} < 1$,
or if ${\tt nvtx} < 1$,
an error message is printed and the program exits.
%-----------------------------------------------------------------------
\item
\begin{verbatim}
IVL * SymbFac_initFromPencil ( ETree *etree, Pencil *pencil ) ;
\end{verbatim}
\index{Symbfac_initFromPencil@{\tt Symbfac\_initFromPencil()}}
This first symbolic factorization method takes a {\tt Pencil} object
as input and is used to compute the symbolic factorization for
a matrix pencil $A - \sigma B$.
This method constructs an {\tt IVL} object that contains one list
per front. 
List {\tt ilist} contains the internal and external vertices
for front {\tt ilist}.
We assume that both the {\tt ETree} and {\tt InpMtx} objects have
had been permuted into their final ordering.
The {\tt nodwghtsIV} and {\tt bndwghtsIV} objects for the 
{\tt ETree} object are updated using information from the symbolic
factorization.
\par \noindent {\it Error checking:}
If {\tt etree} or {\tt inpmtxA} is {\tt NULL},
or if the coordinate type of either internal {\tt InpMtx} objects 
is not {\tt INPMTX\_BY\_CHEVRONS},
or if the storage mode of either internal {\tt InpMtx} objects 
is not {\tt INPMTX\_BY\_VECTORS},
or if ${\tt nfront} < 1$,
or if ${\tt nvtx} < 1$,
an error message is printed and the program exits.
%-----------------------------------------------------------------------
\end{enumerate}
